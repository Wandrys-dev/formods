#'@importFrom digest digest

#'@export
#'@title Fetchs data set views when both UD and DW modules are in use
#'@description The upload data and data wranling modules can be used together.
#' This will take the ids for both modules and return the different views
#' available. It will also return an "acive" view. This either the uploaded
#' dataset if no wrangling information is available or the last wrangled view.
#'@param state Current module state after yaml file has been read
#'@param id_UD  ID string for the upload data module used to handle uploads or
#'the name of the list element in react_state where the data set is stored.
#'@param id_DW  ID string for the data wrangling module used to process any uploaded data
#'@param react_state Variable passed to server to allow reaction outside of module (\code{NULL})
#'@return list containing the current dataset with the following format:
#' \itemize{
#'   \item{isgood:} Boolean indicating the whether a dataset was found
#'   (\code{FALSE})
#'   \item{dsviews:}
#'     \itemize{
#'       \item{dsv_summary:} Dataframe summarizing the available views
#'       \item{contents:} List containing the contents of the data views
#'       \item{columns:} List containing the columns names from the contents.
#'       \item{checksum:} List containing a checksum of the data view. You can
#'       use this to detect changes in that view.
#'   }
#' \item{UD_checksum:} Checksum used to detect changes in the source dataset
#' from the UD module (\code{NULL} if not found).
#' \item{DW_checksum:} Checksum used to detect changes in any of the views
#' from the DW module (\code{NULL} if not found).
#' \item{active:} Data view key for the active data view. If no DW views were
#' round it will just be "default". If there are DW views it will return the
#' active DW view.
#' }
#' The named elements in the lists discussed in \code{dsviews}
#' are either "default" for the originally loaded dataset or a unique key
#' generated by the DW module.
FM_fetch_dsviews = function(state, id_UD, id_DW, react_state){

  # Creating default values for the dataset contents, checksum, etc
  checksum     = list()
  columns      = list()
  contents     = list()
  code         = list()
  object_name  = list()
  isgood       = FALSE
  dsv_summary  = NULL
  DW_checksum  = NULL
  UD_checksum  = NULL
  active       = ""


  # First we check the upload data module
  if(id_UD %in% names(react_state)){
    tmp_checksum    = isolate(react_state[[id_UD]][["DS"]][["checksum"]])
    tmp_contents    = isolate(react_state[[id_UD]][["DS"]][["contents"]])
    tmp_object_name = isolate(react_state[[id_UD]][["DS"]][["object_name"]])
    tmp_code        = isolate(react_state[[id_UD]][["DS"]][["code"]])
    # If both of these are not null then we're good:
    if(!is.null(tmp_checksum)    &
       !is.null(tmp_object_name) &
       !is.null(tmp_contents)){
      # We set this to true since we've found at least
      # one valid data set
      isgood      = TRUE
      # Appending the default view to the list of data set views:
      dsv_summary     = rbind(dsv_summary,
       data.frame(
         checksum    = tmp_checksum,
         object_name = tmp_object_name,
         view_key    = "default",
         code        = tmp_code    ,
         dsm         = "UD",
         description = state[["yaml"]][["FM"]][["labels"]][["default_ds"]]
       ))

      # This default will be selected unless it's overwritten when
      # looking at the contents of the DW module
      active = "default"

      # Appending the columns
      contents[[active]]    = tmp_contents
      checksum[[active]]    = tmp_checksum
      columns[[active]]     = names(tmp_contents)
      code[[active]]        = tmp_code
      object_name[[active]] = tmp_object_name

      # The checksum for the view is the same as that for the
      # entire module
      UD_checksum = tmp_checksum
    }
  }

  # Next we append any data views from the
  # Data wrangling module
  if(id_DW %in% names(react_state)){
    browser()
  }


  # putting it all together
  res = list(
    isgood        =  isgood,
     dsviews       =  list(
       dsv_summary = dsv_summary,
       contents      = contents,
       checksum      = checksum,
       columns       = columns,
       code          = code,
       object_name   = object_name),
    UD_checksum   = UD_checksum,
    DW_checksum   = DW_checksum,
    active        =  active)

res}

#'@export
#'@title Automatically Cast UI Input Variable
#'@description Takes UI input and tries to figure out if it's numeric or text
#'@param ui_input UI input from a shiny form
#'@param quote_char TRUE will include double quotes in the character string
#'@return Best guess of type casting applied to the ui_input
autocast = function(ui_input, quote_char=TRUE){


  ui_input_num = as.numeric(as.character(ui_input))

  if(any(is.na(ui_input_num))){
    res = as.character(ui_input)
    if(quote_char){
      res = paste0('"', res, '"')
    }
  } else {
    res = ui_input_num
  }

res}



#'@export
#'@title Remove Factor From Object
#'@description Takes an object that is a factor and returns an unfactored
#'vector with the same type by the value removed
#'@param fctobj Factorized object
#'@return Object with factors removed
unfactor = function(fctobj){
  res = fctobj
  if(is.factor(fctobj)){
    objtype = typeof(fctobj)
    cmd = paste0("res = as.", objtype,"(as.character(fctobj))");
    eval(parse(text=cmd))
  }
res}


#'@export
#'@title Detect if a UI element has changed
#'@description Takes a UI element value and an older value and determines if
#'it has been modified
#'@param ui_val     Current value from the UI.
#'@param old_val    Last value of of the element.
#'@param init_value Default value for reading in UI data when it has not been
#'defined.
#'@return Boolean result of the comparison
has_changed = function(ui_val     = NULL,
                       old_val    = NULL,
                       init_value = c("")){
  res = FALSE
  # We only Sure
  if(!is.null(ui_val)){
    if(ui_val    != 0 & ui_val   !=init_value){
      if(ui_val    != old_val){
        res = TRUE
      }
    }
  }
res}

#'@export
#'@title Removes Hold on UI Element
#'@description When some buttons are clicked they will change the state of the
#'system, but other UI components will not detect that change correctly. So those
#'triggers are put on hold. This will remove the hold after those UI
#'components have updated.
#'@param state module state with all of the current ui elements populated
#'@param id Shiny module ID
#'@param session Shiny session variable
#'@param inputId The input ID of the UI element that was put on hold
#'@return NULL
remove_hold = function(state, session, inputId){

  FM_ID    = state[["SESSION_LOCATION"]]
  MOD_TYPE = state[["MOD_TYPE"]]

  # pulling out the state
  state = session$userData[[FM_ID]]

  # removing hold on inputId
  state[[MOD_TYPE]][["ui_hold"]][[inputId]] = FALSE

  # Saving the state
  session$userData[[FM_ID]] = state

NULL}

#'@export
#'@title Fetches the path to the log file
#'@description Use this to get the path to the formods log file
#'@param state module state after yaml read
#'@return Character string with the path to the log file.
FG_fetch_log_path = function(state){

  res = state[["yaml"]][["FM"]][["logging"]][["log_file"]]

  if(!is.null(state[["yaml"]][["FM"]][["logging"]][["use_tmpdir"]])){
    if(state[["yaml"]][["FM"]][["logging"]][["use_tmpdir"]]){
      res  = file.path(tempdir(), res)
    }
  }
res}


#'@export
#'@title Appends entry to log file 
#'@description Add the supplied txt and the module type to the log file
#'@param state module state after yaml read
#'@param entry text to add
#'@return NULL
FM_le = function(state, entry){
  # pulling out the log file
  log_file = FG_fetch_log_path(state)

  isgood = NULL

  # If the log file does not exist we initalize it
  if(!file.exists(log_file)){
    file.create(log_file)
    write("for mods log init", file=log_file, append=TRUE)
  }

  # module type
  if(is.null(state[["MOD_TYPE"]])){
    mod_type = "UK"
  }else {
    mod_type = state[["MOD_TYPE"]]
  }

  # Appending the module type:
  entry = paste0(mod_type, ": ", entry)

  # Writing messages to the console
  if(state[["yaml"]][["FM"]][["logging"]][["console"]]){
    cli::cli_alert(entry)
  }

  # Appending the optional time stamp
  if(state[["yaml"]][["FM"]][["logging"]][["timestamp"]]){
     entry = paste0(format(Sys.time(), 
                           state[["yaml"]][["FM"]][["logging"]][["timestamp_fmt"]]),
                    " ", entry)

  }

  # Appending the log entry to the log file
  isgood = write(entry, file=log_file, append=TRUE)

isgood}



#'@export
#'@title Rung Try/Catch and Process Results
#'@description Add the supplied txt and the module type to the log file
#'@param cmd    R command to evaluate in the try/catch block
#'@param tc_env list of with names corresponding to object names and
#'corresponding Values to define in the try/catch environment
#'@param capture Character vector of values to capture after the command is
#'successfully captured
#'@return NULL
FM_tc = function(cmd, tc_env, capture){

  isgood = TRUE
  tcres  = list()
  msgs   = c()

  # Defining the environment
  for(name in names(tc_env)){
    assign(name, tc_env[[name]])
  }

  tcres = tryCatch({
    # Running the command
    eval(parse(text=cmd))
    # Capturing objects
    obj_cap = list()
    for(obj_name in capture){
      obj_cap[[obj_name]] = get(obj_name)
    }
    list(capture = obj_cap, isgood=TRUE)},
    error = function(e) {
      list(error=e, isgood=FALSE)}
  )


  # If there was an error we want to capture any messages from that here
  if(!tcres$isgood){
    if(!is.null(tcres[["error"]][["message"]])){
      msgs = c(msgs, paste0("message: ", tcres[["error"]][["message"]])) }
    if(!is.null(tcres[["error"]][["call"]])){
      msgs = c(msgs, paste0("call:    ", tcres[["error"]][["call"]])) }
  }



  tcres[["msgs"]] = msgs

tcres}


#'@export
#'@title Generates `ggplot` Object with Error Message
#'@description Takes a vector of messages and returns a ggplot object with the
#'text in the figure. This can be used in automated figure generation to
#'cascade an error message to the end user.
#'@param msgs Vector of error messages
#'@return ggplot object
FM_mk_error_fig  <- function(msgs){
  p_res = ggplot()+annotate("text",
                   hjust= 0, vjust=1,
                   x=0, y=0,
                   label = paste(msgs, collapse="\n")) +
    xlab(NULL) + ylab(NULL)  + theme(axis.ticks = element_blank()) +
    scale_x_continuous(labels = NULL, limits = c(-.1,1))        +
    scale_y_continuous(labels = NULL, limits = c(-1,0))

p_res}
